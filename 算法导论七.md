# 算法导论七 贪心法

## 1. 设计要素

* 例子：活动选择问题
* 证明：
  * 按步骤归纳活动选择
  * 按规模归纳装载问题
  * 交换论证、最小延迟调度
* 得不到最优解的处理：找零钱问题的参数化分析

## 2. 例子:活动选择问题

![JMze9x.png](https://s1.ax1x.com/2020/04/20/JMze9x.png)

### 2.1 贪心算法

挑选过程是一个多步判断，每步按照某种“短视”的策略进行选择，满足相容性条件。

* 策略1：从开始时间早的优先排序使得 $s_{1}\leq s_{2}\leq ...\leq s_{n}$
* 策略2：占用时间少的优先排序，使得 $f_{1}-s_{1}\leq f_{2}-s_{2} \leq ... \leq f_{n}-s_{n}$
* 策略3：结束早的优先

### 2.2 策略1的反例

![JQ9S3t.png](https://s1.ax1x.com/2020/04/20/JQ9S3t.png)

### 2.3 策略2的反例

![JQ9G59.png](https://s1.ax1x.com/2020/04/20/JQ9G59.png)

### 2.4 策略3伪代码

Greedy Select

![JQ9DVe.png](https://s1.ax1x.com/2020/04/20/JQ9DVe.png)

### 2.5 策略3时间复杂度

![JQCzOf.png](https://s1.ax1x.com/2020/04/20/JQCzOf.png)

初始按照结束时间排序，然后进行遍历筛选。

$O(nlogn) + O(n) = O(nlogn)$

### 2.6 贪心法思想

* 适用于组合优化问题
* 求解过程是多步判断过程，最终的判断序列对应于问题的最优解
* 依赖某种“短视”的贪心选择性质判断，性质好坏决定算法成败
* 贪心法必须进行正确性证明
* 证明不正确：举反例

## 3. 贪心法的正确性证明

### 3.1 第一数学归纳法

适合证明涉及自然数的命题$P(n)$

**归纳基础**：证明$P(1)$或者$P(0)$为真

**归纳步骤**：若对所有n都有$P(n)$为真，证明$P(n+1)$为真

### 3.2 第二数学归纳法

适合证明涉及自然数的命题

**归纳基础**：证明$P(1)$或者$P(0)$为真

**归纳步骤**：若对所有小于n的k都有$P(k)$为真，证明$P(n)$为真

### 3.3 两种归纳法的区别

归纳基础一样。

归纳步骤不同：

1. $P(1) -> P(2) -> P(3) -> ...$

2. ![JQiHGd.png](https://s1.ax1x.com/2020/04/20/JQiHGd.png)

### 3.4 贪心算法正确性归纳证明

证明步骤：

1. 叙述一个有关自然数n的命题，该命题断定该贪心策略的执行最终将导致最优解，其中自然数n可以代表算法步数或问题规模。
2. 证明命题对所有的自然数为真，归纳基础（从最小实例规模开始）；归纳步骤（第一或第二数学归纳法）。

### 3.5 活动选择算法的命题

![JQFtoD.png](https://s1.ax1x.com/2020/04/20/JQFtoD.png)

![JQAWMn.png](https://s1.ax1x.com/2020/04/20/JQAWMn.png)

![JQE9iD.png](https://s1.ax1x.com/2020/04/20/JQE9iD.png)

![JQEmo8.png](https://s1.ax1x.com/2020/04/20/JQEmo8.png)

### 3.6 小结

* 证明方法：数学归纳法、第一数学归纳法、第二数学归纳法
* 证明：
  * 叙述一个正确性命题
  * 证明归纳基础
  * 证明归纳步骤

## 4. 最优装载问题

### 4.1 问题描述

n个集装箱1,2,...,n装上轮船，集装箱i的重量$w_{i} \leq C$，轮船装载重量限制为C，无体积限制。问如何装使得上船的集装箱最多？

这个问题是0-1背包的子问题。$v_{i}$全部等于1。

背包问题没有多项式求解方法，但是背包问题的子问题确可以有多项式解决时间，因此可以使用贪心法。

### 4.2 建模

解向量 $<x_{1},x_{2},...,x_{n}> , x_{i}=0,1$

目标函数 $max\sum_{i=1}^{n}x_{i}$

约束条件 $\sum_{i=1}^{n}w_{i}x_{i} \leq C, x_{i}=0,1 i = 1,2,...,n$

### 4.3 算法设计

策略：轻者优先。

### 4.4 正确性证明思路

命题：对装载问题任何规模为n的输入实例，算法得到最优解。

箱子从轻到重记录为1,2,...,n

归纳基础：只含一个箱子，贪心法是最优解。

归纳步骤：假设对于任何n个箱子的输入实例贪心法都能得到最优解，对于任何n+1个箱子的输入实例贪心法也能得到最优解。

### 4.5 证明思路

![JQVo34.png](https://s1.ax1x.com/2020/04/20/JQVo34.png)

假设对于n个箱子的输入，贪心法都可以得到最优解。考虑输入:

$$N = {1,2,...,N+1}$$

其中$w_{1} \leq w_{2} \leq ... \leq w_{n+1}$

根据归纳假设，对于$N' = {2,...,N+1}, C'=C-w_{1}$

贪心法得到最优解$I'$,令$I = I' \bigcup {1}$

要证明：I是N的最优解。

若不然，存在包含1的关于N的最优解$I^{*}$

（如果$I*$中没有1，用1替代$I*$中的第一个元素得到的解也是最优解），且$|I^{*}| > |I|$,那么$I^{*}-\{1\}$也是$N'$和$C'$的解，且

$$|I^{*}-\{1\}| > |I-\{1\}| = |I'|$$

这与$|I'|$是关于$N'$和$C'$的最优解矛盾。因此I是N的最优解。


### 4.6 小结

* 装载问题是0-1背包的子问题，NP难问题存在多项式时间可解的子问题。
* 贪心法证明：对规模归纳。

## 5. 最小延迟调度问题

### 5.1 问题描述

客户集合A，$\forall i \in A, t_{i}$是服务时间，$d_{i}$是要求完成时间，$t_{i},d_{i}$为正整数。一个调度f:A->N,f(i)为客户i的开始时间。求最大延迟达到的最小的调度。即求f使得

$$min_{f}\{max_{i\in A}\{f(i)+t_{i}-d_{i}\}\}$$

![JQuewn.png](https://s1.ax1x.com/2020/04/20/JQuewn.png)

![JQuaY6.png](https://s1.ax1x.com/2020/04/20/JQuaY6.png)

### 5.2 贪心策略

* 按照$t_{i}$从小到大安排
* 按照$d_{i}-t_{i}$从小到大安排
* 按照$d_{i}$从小到大安排

反例：

* 策略1：$t_{1}=1,d_{1}=100,t_{2}=10,d_{2}=10$
* 策略3：$t_{1}=1,d_{1}=2,t_{2}=10,d_{2}=10$


### 5.3 策略3伪代码

![JQKJgS.png](https://s1.ax1x.com/2020/04/20/JQKJgS.png)

### 5.4 交换论证：正确性证明

* 分析一般最优解与算法解的区别（成分，排列顺序不同）
* 设计一种转换操作（替换成分或交换次序），可以在有限步将任意一个普通最优解逐步转化为算法的解
* 上述每步转换都不降低解调度最优性质

贪心算法的解的性质: 没有空闲时间，没有逆序。

逆序(i,j): f(i) < f(j) 且 $d_{i} > d_{j}$

#### 5.4.1 引理

引理1：所有没有逆序，没有空闲时间的调度具有相同的最大延迟。

![JQMlqJ.png](https://s1.ax1x.com/2020/04/20/JQMlqJ.png)

这里讲的是：在$t_{0}$到$t$中间都是限制时间为d的安排。那么完成这些让任务的时间肯定是t，最大延迟都是最后的活动减去限制时间，即：t-d。与$i_{1},i_{2},...$排序无关。

#### 5.4.2 证明要点

算法的解和逆序的解是等价的。

从一个没有空闲的最优解出发，逐步转变为没有逆序的解。根据引理1，这个解和算法解具有相同的最大延迟。

1. 如果一个最优调度存在逆序，那么存在i < n，使得(i,i+1)构成一个逆序，称为相邻的逆序。
2. 交换相邻逆序i和j，得到的解仍旧是最优。
3. 每次交换后逆序数减1，至多经过n(n-1)/2次交换得到一个没有逆序的最优调度——等价于算法的解。

#### 5.4.3 交换相邻逆序i和j，得到的解仍旧是最优

设f1是任意一个最优解，存在相邻逆序(i,j)。交换i和j的顺序，得到解f2.那么f2的最大延迟不超过f1的最大延迟。

原理：

1. 交换i和j与其他客户延迟时间无关。
2. 交换后不增加j的延迟，但可能增加i的延迟
3. i在f2的延迟小于j在f1的延迟，因此小于f1的最大延迟r。

逆序这里就是指这两个延迟时间本来由小到大，现在交换一下。

前面和后面的都不会受到影响，那么 根据图中公式的计算，两个方法delay的变化都小于第一个调度的最大延迟。

![JQ3Soj.png](https://s1.ax1x.com/2020/04/20/JQ3Soj.png)

### 5.5 小结

贪心法正确性证明方法：交换论证

* 分析算法解与一般最优解的区别，找到把一般解改造城算法解的一系列操作（替换成分，交换次序）
* 证明操作步数有限
* 证明每步操作后得到解仍然保持最优

## 6. 得不到最优解的解决方法

### 6.1 处理方法

* 输入参数分析

考虑输入参数在什么取值范围内使用贪心法可以得到最优解。

* 误差分析

估计贪心法——近似算法所得到的解与最优解的误差（对所有的输入实例在最坏的情况下误差的上界）

### 6.2 找零钱问题 v1 = 1

假设有n种零钱，重量是$w_{1},w_{2},...w_{n}$，价值分别为$v_{1}=1,v_{2},...$，需要支付的总钱数是y。不妨假设币值和钱数都是正整数。问：如何付钱使得钱的总重量最轻。

例子：
$v_{1}=1,v_{2}=5,v_{3}=14,v_{4}=18,w_{i}=1,\forall i \in [1,4], y=28$

最优解：$x_{3}=2$

### 6.3 建模

$min\{\sum_{i=1}^{n}w_{i}x_{i}\}$

$\sum_{i=1}^{n}v_{i}x_{i}=y, x_{i} \in N, i = 1,2,...,n$

### 6.4 动态规划算法

$F_{k}(y)$表示用前k种零钱，总钱数为y的最小重量。

$F_{k}(y) = min_{0 \leq x_{k} \leq \lfloor \frac{y}{v_{k}} \rfloor} \{ F_{k-1}(y-v_{k}x_{k}) + w_{k}x_{k}\}$

$F_{1}(y) = w_{1}\lfloor \frac{y}{v_{1}} \rfloor = w_{1}y$

### 6.5 贪心法

单位价值重量轻的货币优先

$$\frac{w_{1}}{v_{1}} \geq \frac{w_{2}}{v_{2}} \geq ... \geq \frac{w_{n}}{v_{n}}$$

试用前k种零钱，总钱数为y，贪心法的总重量为 $G_{k}(y)$

$$G_{k}(y) = w_{k}\lfloor \frac{y}{v_{k}} \rfloor +  G_{k-1}(y\quad mod\quad v_{k})$$

$$G_{1}(y) = w_{1}\lfloor \frac{y}{v_{1}} \rfloor = w_{1}y$$

#### 6.5.1 n=1,2是最优解

n = 1 只有一种钱，肯定最优

n = 2 $x_{2}$越大，得到的解越好

证明过程:

![JlPyMq.png](https://s1.ax1x.com/2020/04/20/JlPyMq.png)

#### 6.5.2 判别条件

定理：对每个正整数k，假设对所有非负整数y有$G_{k}(y) = F_{k}(y)$，且存在$p$和$\delta$满足：

$$v_{k+1} = pv_{k} - \delta$$

其中$0 \leq \delta < v_{k}, v_{k} \leq v_{k+1}, p$ 为正整数。

下列命题等价：

1. $G_{k+1}(y) = F_{k+1}(y)$ 贪心法对k+1种前是正确的
2. $G_{k+1}(pv_{k}) = F_{k+1}(pv_{k})$特例，用于验证出错的地方
3. $w_{k+1} + G_{k}(\delta) \leq pw_{k}$主要用来判断贪心法的正确性

根据条件1和3的等价性，可以对k=3,4,5,...,n依次使用条件3对贪心法是否得到最优解做出判别。

条件3验证一次需要$O(k)$时间，$k=O(n)$，整个验证时间$O(n^{2})$

条件2是条件1在$y=pv_{k}$时的特殊情况，若条件1成立，显然条件2成立。反之如果条件2不成立，则条件1不成立。钱数$y=pv_{k}$恰好提供了一个贪心法不正确的反例。

#### 6.5.3 验证实例

![JlkyQA.png](https://s1.ax1x.com/2020/04/20/JlkyQA.png)

![JlAEFO.png](https://s1.ax1x.com/2020/04/20/JlAEFO.png)

解释：这里先使用单位价值重量轻的纸币(1/18)，于是就用了第4种。那么第三种就没法用了，这个时候就需要使用多张小币值的纸币了。

### 6.6 小结

贪心算法不一定得到最优解，在这种情况下可以用两种处理方法：

1. 参数化分析：分析参数取什么值的时候可以得到最优解。（命题三）
2. 估计贪心法得到的解在最坏情况下与最优解的差距。（命题二）

